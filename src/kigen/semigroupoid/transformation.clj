(ns kigen.semigroupoid.transformation
  "Transformation semigroupoids.
   :s - source, domain
   :t - target, codomain
   :m - morphism, map"
  (:require [clojure.set :refer [union]]
            [orbit.core :refer [full-orbit]]))

(declare compose
         sgpoid-by-gens)

(defn compose
  "Composition of typed transformations.
   Given a nd b, the arrow a then b is returned. Note the automata
   theoretic composition.
   Returns nil when the arrows a and b are not composable."
  [a b]
  (when (= (:t a) (:s b)) ;checking composability
    {:s (:s a) ;the source is the source of a
     :t (:t b) ;the target is the target of b
     :m (mapv (:m b) (:m a))})) ; clj vectors are functions!

(defn arrow-type
  "Returns the type signature of an arrow, the domain-codomain, source-target
   pair in a vector."
  [a]
  [(:s a), (:t a)])

(defn sgpoid-by-gens
  "Returns the elements of the semigroupoid generated by the typed
   transformations given in gens."
  [gens]
  (let [sources (group-by :s gens) ;looks up generators with given source
        targets (group-by :t gens) ;looks up generatos with given target
        generator-fn ;takes an arrow and prepend/append all matching gens
        (fn [a]
          (union
           (set (map (partial compose a) ;append generator
                     (sources (:t a)))) ;nil is ok for map
           (set (map #(compose % a) ;prepend generator
                     (targets (:s a))))))]
    (full-orbit gens generator-fn)))



(defn morphisms-by-type
  "Returns a hash-map with  keys as types, i.e., [dom,codomain] pairs, and values as the set of all arrows of that type."
  [S]
  (update-vals
   (group-by arrow-type S)
   (comp set ;TODO do we need set? transformations of same type form a set
         (partial map :m)))) ;stripping off the type information

(def S (sgpoid-by-gens [{:s 0, :t 0, :m [1 0]}
                        {:s 1, :t 1, :m [1 2 0]}
                        {:s 0, :t 1, :m [0 0]}
                        {:s 1, :t 0, :m [0 0 0]}]))
(def S2 (sgpoid-by-gens [{:s 0 :t 0 :m [1 0]} ;a
                           ;{:s 0 :t 0 :m [0 1]} ;b
                         {:s 0 :t 1 :m [0 1]} ;c
                           ;{:s 0 :t 1 :m [1 0]} ;d
                         {:s 0 :t 1 :m [0 0]} ;e
                         {:s 1 :t 1 :m [0 0]} ;f
                         ]))

(defn sort-by-type
  "The elements of the semigroupoid sorted by type then by transformations."
  [S]
  (sort-by
   #(into (arrow-type %) (:m %)) ; sort by type+transformation
   S))

(defn comptab
  "The composition table for semigroupoid sorted by type."
  [S]
  (let [ordered (sort-by-type S)
        arrow2index (zipmap ordered (range))]
    (for [a ordered]
      (mapv (comp arrow2index (partial compose a)) ordered))))

; for semigroupoids with less then 52 elements we can some symbolic printouts
(def symbols "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ")

(defn symbols-for-elts
  "For checking the symbols and their corresponding elements."
  [S]
  (map vector symbols (sort-by-type S)))

(defn symbol-comptab
  "Sequence of strings representing the composition table of the semigroupoid
   sorted by type and transformation."
  [S]
  (let [converter (conj (zipmap (range) symbols) [nil \.])]
    (map (comp (partial apply str)
               (partial map converter))
         (comptab S))))

