(ns kigen.semigroupoid.transformation
  "Transformation semigroupoids.
   :s - source, domain
   :t - target, codomain
   :m - morphism, map"
  (:require [clojure.set :refer [union]]
            [orbit.core :refer [full-orbit]]))

(declare compose
         sgpoid-by-gens)

; example transformation semigroupoid
(def ExA1 ; example from semigroupoid paper
  {:objects [2,3]
   :gens [{:s 0, :t 0, :m [1 0]}
          {:s 1, :t 1, :m [1 2 0] }
          {:s 0, :t 1, :m [0 0]}
          {:s 1, :t 0, :m [0 0 0]}]})

(defn compose
  "Composition of typed transformations.
   Given a nd b, the arrow a then b is returned. Note the automata
   theoretic composition.
   Returns nil when the arrows a and b are not composable."
  [a b]
  (when (= (:t a) (:s b)) ;checking composability
    {:s (:s a) ;the source is the source of a
     :t (:t b) ;the target is the target of b
     :m (mapv (:m b) (:m a))})) ; clj vectors are functions!

(defn morphisms
  "Returns a hash-map with key [dom,codomain] pairs and values are the
   corresponding arrows."
  [S]
  (update-vals
   (group-by (fn [a] [(:s a) (:t a)]) S)
   (partial map :m)))

(defn sgpoid-by-gens
  "Returns the elements of the semigroupoid generated by the typed
   transformations given in gens."
  [gens]
  (let [sources (group-by :s gens) ;looks up generators with given source
        targets (group-by :t gens) ;looks up generatos with given target
        generator-fn ;takes an arrow and prepend/append all matching gens
        (fn [a]
          (union
           (set (map (partial compose a) ;append generator
                     (sources (:t a)))) ;nil is ok for map
           (set (map #(compose % a) ;prepend generator
                     (targets (:s a))))))]
    (full-orbit gens generator-fn)))

(sgpoid-by-gens (:gens ExA1))
(def ExA1full (sgpoid-by-gens (:gens ExA1)))

(morphisms ExA1full)
(count ExA1full)