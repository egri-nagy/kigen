(ns kigen.semigroupoid.transformation
  "Transformation semigroupoids.
   :s - source, domain
   :t - target, codomain
   :m - morphism, map"
  (:require [clojure.set :refer [union]]
            [orbit.core :refer [full-orbit]]))

(declare compose
         sgpoid-by-gens)

(defn compose
  "Composition of typed transformations. Given a and b, the composite arrow a
   then b is returned.
   Note the automata theoretic composition notation!
   Returns nil when the arrows a and b are not composable."
  [a b]
  (when (= (:t a) (:s b)) ;checking composability
    {:s (:s a) ;the source is the source of a
     :t (:t b) ;the target is the target of b
     :m (mapv (:m b) (:m a))})) ; clj vectors are functions!

(defn sgpoid-by-gens
  "Returns the elements of the semigroupoid generated by the typed
   transformations given in gens."
  [gens]
  (let [sources (group-by :s gens) ;looks up generators with given source
        targets (group-by :t gens) ;looks up generatos with given target
        generator-fn ;takes an arrow and prepend/append all matching gens
        (fn [a]
          (union
           (set (map (partial compose a) ;append generator
                     (sources (:t a)))) ;nil is ok for map
           (set (map #(compose % a) ;prepend generator
                     (targets (:s a))))))]
    (full-orbit gens generator-fn)))

(defn arrow-type
  "Returns the type signature of an arrow, the domain-codomain, source-target
   pair in a vector."
  [a]
  [(:s a), (:t a)])

(defn graph
  "Returns the underlying graph of the arrow collection S."
  [S]
  (reduce (fn [g a]
            (conj g (arrow-type a)))
          #{}
          S))

(defn arrows-by-type ;todo What's the use?
  "Returns a hash-map with  keys as types, i.e., [dom,codomain] pairs,
   and values as the set of all arrows of that type."
  [S]
  (update-vals
   (group-by arrow-type S)
   (comp set ;TODO do we need set? transformations of same type form a set
         (partial map :m)))) ;stripping off the type information

(defn sort-by-type
  "The elements of the semigroupoid sorted by type then by transformations."
  [S]
  (sort-by
   #(into (arrow-type %) (:m %)) ; sort by type+transformation
   S))

(defn comptab
  "The composition table for semigroupoid sorted by type. "
  [S]
  (let [ordered (sort-by-type S)
        arrow2index (zipmap ordered (range))]
    (for [a ordered]
      (mapv (comp arrow2index (partial compose a)) ordered))))

; for semigroupoids with less then 52 elements we can some symbolic printouts
(def symbols "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ")

(defn symbols-for-elts
  "For checking the symbols and their corresponding elements."
  [S]
  (map vector symbols (sort-by-type S)))

(defn symbol-comptab
  "Sequence of strings representing the composition table of the semigroupoid
   sorted by type and transformation. nils replaced by dots"
  [S]
  (let [converter (conj (zipmap (range) symbols) [nil \.])]
    (map (comp (partial apply str)
               (partial map converter))
         (comptab S))))