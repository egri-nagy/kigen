(ns kigen.semigroup.genmorph
  "Constructing isomorphisms/embeddings between semigroups given  by generators.
  In other words, searching for an isomorphisms of Cayley-graphs.
  The elements of both semigroups are fully enumerated.
  The source semigroup is converted to generator table (partial multiplication
  table containing all the images of right multiplication by generators).
  The elements of target semigroups are classified by their index-periods in
  order to find possible targets for generators.
  Canonical notation for the data structure for Cayley-graph matching is M.
   It's a hasmap with keys :phi :Sgens :Smul :Tmul. Phi is the morphism
   (hash-map) that is induced by matching the (sub)semigroup generated by
   :Sgens."
  (:require [kigen.semigroup.sgp :refer [sgp-by-gens index-period]]
            [kigen.table.gentab :refer [gentab]]
            [kigen.canonical-labeling :refer [can-set-seq can-seq-seq can-lab-seq-seq can-seq]]
            [orbit.core :refer [ptree-search-depth-first]] ;tree-search for single-threaded execution
            [clojure.core.reducers :as r]
            [kigen.memory-info :refer [mem-info]]
            [taoensso.timbre :refer [trace]]))

(declare new-mapping
         add-gen-and-close
         embeddings ;; high-level function for finding embeddings
         embeddings-distinct
         sgp-embeddings-by-gens ;;main entry point
         index-period-matched) ;;preparation

(defn gen-map
  "Extracts the mappings of the S generators to T generators from a Cayley
   graph morphic match."
  [{phi :phi gens :Sgens}]
  (zipmap gens (map phi gens)))

(defn index-period-matched
  "Returns for each generator in S, the elements of T with matching index-period
  values. WARNING: It fully enumerates T."
  [Sgens Smul Tgens Tmul]
  (let [S-index-period (partial index-period Smul)
        T-index-period (partial index-period Tmul)
        T (sgp-by-gens Tgens Tmul)
        Tip->Tset (group-by T-index-period T)] ;todo: wasteful collection!
    (mapv Tip->Tset (map  S-index-period Sgens))))

(defn sgp-embeddings-by-gens
  "Computes all embeddings from source semigroup to target semigroup.
  Semigroups are given by generators and their multiplication functions. Source
  semigroup is replaced by its generation table. It returns a list of maps
  containing the images of the source generators, or an empty list.
  Results are up to conjugation if conjugation action and symmetries are given."
  ([Sgens Smul Tgens Tmul] ; ALL EMBEDDINGS
   (let [{mSgens :gens mSmul :mul} (gentab Sgens Smul)]
     (map (fn [m] (zipmap Sgens (map m mSgens))) ; mappings of the generators
          (embeddings mSgens
                      mSmul
                      (index-period-matched mSgens mSmul Tgens Tmul)
                      Tmul))))
  ([Sgens Smul Tgens Tmul conj-fn-bundle] ; ALL EMBEDDINGS UP TO CONJUGATION
   (let [{mSgens :gens mSmul :mul} (gentab Sgens Smul)]
     (map (fn [m] (zipmap Sgens (map m mSgens)))
          (embeddings-distinct mSgens
                               mSmul
                               (index-period-matched mSgens mSmul Tgens Tmul)
                               Tmul
                               conj-fn-bundle)))))

(defn bijective?
  "Returns true if the given hash-map is bijective, i.e., the values are all
   distinct."
  [m]
  (apply distinct? (vals m)))

(defn embeddings
  "All embeddings of source semigroup into target induced by the possible
  images of the generators."
  [Sgens Smul targets Tmul]
  (trace (str "Number of targets:" (vec (map count targets))))
  (let [solution? (fn [M] (= (count (:Sgens M)) (count Sgens)))
        generator (fn [{phi :phi :as M}]
                    (if (solution? M)
                      []
                      (let [n (count (:Sgens M))
                            g (nth Sgens n)
                            addgen (fn [G] ; G is the candidate generator in G
                                     (when-not (some #{G} (vals phi)) ;no dups!
                                       (add-gen-and-close M g G)))
                            result (r/reduce
                                    conj
                                    []
                                    (->>
                                     (r/map addgen (nth targets n))
                                     (r/remove nil?)
                                     (r/filter (comp bijective? :phi))))]
                        (trace (str "#gens:" n
                                    " #phi:" (count phi)
                                    " #targets:" (count (nth targets n))
                                    " #extensions:" (count result)))
                        result)))]
    (map gen-map
     (ptree-search-depth-first
      [{:phi {} :Sgens [] :Smul Smul :Tmul Tmul}] ;empty M
      generator
      solution?))))


(defn embedding-backtrack
  "Finding an embedding of source semigroup into target induced by the possible
  images of the generators by a backtrack algorithm.
  If `all?` is set, it returns the collection of solutions, otherwise just a
  single solution found first."
  [Sgens Smul tgs Tmul all?]
  (trace (str "Number of targets:" (vec (map count tgs))))
  (let [N (count Sgens)] ;; the max number of levels
    (loop [n 0 ;the number of generators mapped so far
           morphs [{:phi {} :Sgens [] :Smul Smul :Tmul Tmul}] ;empty morph match
           coords [-1] ;placeholder value, when inc-ed, it points to valid 0th
           solutions []]
      (if (< n 0) ;when bactracked too far, return the solutions
        solutions
        ;; we try the next coordinate value if available
        (if-not (< (coords n) (dec (count (tgs n))))
          (recur (dec n) ;backtrack when no more coordinate values available
                 (pop morphs)
                 (pop coords)
                 solutions)
          (let [g (nth Sgens n)
                ncoord (inc (coords n))
                G ((tgs n) ncoord)
                M (peek morphs)
                nM (add-gen-and-close M g G)]
            (cond
                ;when we don't have a a good new phi, just go next coordval
              (or (nil? nM) (not (bijective? (:phi nM))))
              (recur n
                     morphs
                     (conj (pop coords) ncoord)
                     solutions)
                ;if it is a solution, just return it or collect it
              (= (count coords) N)
              (if all?
                (recur n ;collecting all solutions, so move on
                       morphs
                       (conj (pop coords) ncoord)
                       (conj solutions (gen-map nM)))
                (gen-map nM)) ;the first solution
                ;not a solution, but good, so add a new generator
              :else (recur (inc n)
                           (conj morphs nM)
                           (conj (conj (pop coords) ncoord) -1)
                           solutions))))))))

(defn call-embedding
  [Sgens Smul Tgens Tmul] ; ALL EMBEDDINGS
  (let [{mSgens :gens mSmul :mul} (gentab Sgens Smul)]
    (map (fn [m] (zipmap Sgens (map m mSgens))) ; mappings of the generators
         (:phi (embedding-backtrack mSgens
                                    mSmul
                                    (index-period-matched mSgens mSmul Tgens Tmul)
                                    Tmul)))))

(defn class-reps
  "Classifies the elements of coll by function f and keeps only
  a representative element from each class."
  [f coll]
  (map first (vals (group-by f coll))))

(defn morphisms-up-to-conjugation
  "Returns the distinct morphs up to conjugation. First checking by the equality
  of the image set, then by its conjugacy class representative."
  [morphs setconjrep]
  (->> morphs
       (class-reps (comp set vals :phi))
       (class-reps (comp setconjrep vals :phi))))

(defn morphisms-up-to-conjugation2
  "Returns the distinct morphs up to conjugation. First checking by the equality
  of the image set, then by its conjugacy class representative."
  [morphs setconjrep]
  (->> morphs
       (class-reps (comp set vals :phi))
       (class-reps (comp can-set-seq vals :phi))))

(defn new-generator-conjreps
  "Finds the possible target generators up to conjugation. For the very first
  generator it chooses conjugacy class representatives.
   Strategy: compute conjugacy class reps for sequences,
   but filter them with setwise conjugacy."
  [phi n Sgens tgs
   {repconj :conjrep setconjrep :setconjrep conj-conj :conjconj}]
  (println "newgens!")
  (if (zero? n)
    (set (map repconj (first tgs)))
    (let [gens (mapv phi (take n Sgens))
          partconj (reduce conj-conj ; for not computing minconjugators always
                           (conj-conj (first gens))
                           (rest gens))
          conjed_seqs (r/map first
                             (r/map (partial conj-conj partconj)
                                    (nth tgs n)))
          ;we need to keep distinct generator sets
          selected_seqs (class-reps setconjrep conjed_seqs)]
      (into #{} (r/map last selected_seqs))))) ;set does not work here

(defn new-generator-conjreps2
  "Finds the possible target generators up to conjugation. For the very first
  generator it chooses conjugacy class representatives.
   Strategy: compute conjugacy class reps for sequences,
   but filter them with setwise conjugacy."
  [phi n Sgens tgs
   {repconj :conjrep setconjrep :setconjrep conj-conj :conjconj}]
  (println "newgens2!")
  (if (zero? n)
    (set (map can-seq (first tgs)))
    (let [gens (mapv phi (take n Sgens))
          PL (can-lab-seq-seq gens)
          conjed_seqs (r/map (partial can-seq-seq PL)
                             (nth tgs n))
          ;we need to keep distinct generator sets
          grouped (group-by can-set-seq conjed_seqs)
          selected_seqs (map first (vals grouped))]
      (println "hey!" selected_seqs)
      (into #{} (r/map last selected_seqs))))) ;set does not work here

(defn embeddings-distinct
  "All morphisms from embedding seeds, but lossy ones filtered out."
  [Sgens Smul tgs Tmul conj-fn-bundle]
  (println "start!")
  (let [solution? (fn [M] (= (count (:Sgens M)) (count Sgens)))
        generator (fn [{phi :phi :as M}]
                    (if (solution? M)
                      []
                      (let [n (count (:Sgens M))
                            ngens (new-generator-conjreps phi n Sgens tgs
                                                          conj-fn-bundle)
                            check-gen (fn [newmorphs ngen]
                                        (let [nM (add-gen-and-close
                                                  M
                                                  (nth Sgens n)
                                                  ngen)]
                                          (if (and (coll? nM)
                                                   (bijective? (:phi nM))) ;iso?
                                            (conj newmorphs nM)
                                            newmorphs)))
                            result (reduce check-gen [] ngens)]
                        (println "" ngens)
                        (trace (count phi) "elts in phi,"
                               (count ngens) "targets for gen" n ","
                               (count result) "realized" (mem-info))
                        result)))
        morphs (ptree-search-depth-first
                [{:phi {} :Sgens [] :Smul Smul :Tmul Tmul}]
                generator
                solution?)]
    (trace (count morphs) "morphisms found." (mem-info))
    (morphisms-up-to-conjugation morphs (:setconjrep conj-fn-bundle))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Cayley graph morphic matching                                              ;;
;; input: a new mapping of a generator [g G]
;; output: the extended induced homomorphism, if possible 
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defn add-gen-and-close
  "Add a new generator and close the Cayley-graph."
  [{phi :phi gens :Sgens :as M} g G] ;todo just to have a map and the g G pair as input
  (let [new-mapping-fn (partial new-mapping (:Smul M) (:Tmul M))
        ngens (conj gens g)]
    (loop [ephi (conj phi [g G])
           pairs (into (mapv (fn [a] [a g]) (keys phi))
                       (mapv (fn [h] [g h]) ngens))] ;includes [g g]
      (if (empty? pairs)
        (-> M (assoc :phi ephi) (assoc :Sgens ngens)) ;the updated M
        (let [p (new-mapping-fn ephi (peek pairs))]
          (cond (nil? p) nil ;not morphic
                (empty? p) (recur ephi ;we know the product and it is morphic
                                  (pop pairs))
                :else (recur (conj ephi p) ;we extended phi 
                             (into (pop pairs)
                                   (for [g ngens] [(first p) g])))))))))

(defn new-mapping
  "Attempt to extends the morphism `phi` for the product of element `a` by
   generator `g` (both known by phi). The product ag may be known or a new one.
  If phi(ag) is already known and morphic, then an empty vector is returned. 
  If it is newly found, it gives a vector [ag phi(ag)], to conjoin to phi.
  If it is not homomorphic, nil is returned.
  In short, outputs can be nil, [], or [ag phi(ag)].
  `mulS`, `mulT` - multiplication in source S and  in target T"
  [mulS mulT phi [a g]]
  (let [ag (mulS a g) ;the product in S
        AG (mulT (phi a) (phi g))] ;the product in T
    (if (contains? phi ag) ;does phi know this product in S? i.e., has it as a key
      (when (= AG (phi ag)) []) ;morphic? i.e. compatible, nil otherwise
      [ag AG]))) ;to be added to phi